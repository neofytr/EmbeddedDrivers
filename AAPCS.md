The **ARM Architecture Procedure Call Standard (AAPCS)** specifies rules for function calling, argument passing, and stack usage in ARM systems, including Cortex-M microcontrollers. 

---

### **1. Register Usage**
- **General-purpose registers (R0–R12):**
  - `R0–R3`: Used for passing function arguments and returning values.
    - If a function has more than 4 arguments, the additional arguments are passed on the stack.
    - Return values are placed in `R0` (and `R1` for 64-bit values).
  - `R4–R11`: Callee-saved registers. Must be preserved across function calls.
  - `R12` (`IP`): Intra-procedural scratch register, used as a temporary by the compiler.

- **Special registers:**
  - `R13` (`SP`): Stack Pointer. Points to the top of the stack.
  - `R14` (`LR`): Link Register. Holds the return address for function calls.
  - `R15` (`PC`): Program Counter. Points to the next instruction to execute.

---

### **2. Stack Usage**
- **Full Descending Stack:**
  - The stack grows **downwards** (to lower memory addresses).
  - The stack pointer (`SP`) always points to the top byte of the stack.
  
- **8-byte alignment:**
  - The stack pointer must be aligned to an 8-byte (4-byte on Cortex M) boundary at all times, especially during function calls.

---

### **3. Function Call Conventions**
- **Argument passing:**
  - The first 4 arguments are passed in `R0–R3`.
  - Additional arguments are passed on the stack in **reverse order** (last argument placed first).

- **Return values:**
  - Single-word return values are passed in `R0`.
  - Double-word return values (e.g., 64-bit integers) use `R0` and `R1`.

- **Caller responsibilities:**
  - Save and restore `R0–R3` and `R12` if needed after the function call.
  
- **Callee responsibilities:**
  - Save and restore `R4–R11` if modified within the function.

---

### **4. Stack Frame Organization**
- **Stack frame layout:**
  - Return address (saved in `LR`).
  - Local variables.
  - Saved registers (`R4–R11`) if used.

- **Frame pointer (`R7`):**
  - Commonly used to mark the start of the current stack frame, though not mandatory for all functions.

---

### **5. Floating-Point Registers (Optional)**
- **VFP registers (`S0–S31`):**
  - If the floating-point unit (FPU) is used:
    - `S0–S15`: Caller-saved.
    - `S16–S31`: Callee-saved.
  - Floating-point arguments and return values are passed using these registers when enabled.

---

### **6. Interrupt Handling**
- Cortex-M processors automatically save `R0–R3`, `R12`, `LR`, `PC`, and the xPSR register on the stack when an interrupt occurs.
- Upon returning from the interrupt, the processor restores these registers automatically.

---

### **7. Thumb Instruction Set**
- Cortex-M cores use the **Thumb instruction set**, which supports only 16-bit and 32-bit instructions. This affects code density and the use of certain registers.

---

### **8. ABI Compliance**
- Complies with the **EABI (Embedded Application Binary Interface)**:
  - Ensures interoperability between code generated by different compilers.

---

### Key Takeaways for Developers:
- Use `R0–R3` for function arguments and return values.
- Preserve `R4–R11` in functions if modified.
- Maintain 8-byte stack alignment.
- Use the `SP` as the sole stack pointer (no dual stack model in Cortex-M).
- Floating-point rules apply only if the FPU is used and enabled.

This adherence ensures portability and consistency across tools and libraries. 